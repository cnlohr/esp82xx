define USAGE
Usage: make [command] [VARIABLES]

all....... Build the binaries
debug..... Build a .map and .lst file.  Useful for seeing what's going on
           behind the scenes.
burn ..... Write firmware to chip using a regular serial port
burnweb .. Write data for the Web-GUI to chip using a regular serial
           port
netburn .. Same as 'burn' but transfer firmware over the network rather
           than the serial port (if supported by the existing firmware
           on the chip)
netweb ... Same as 'burnweb' but transfer data over network if supported
           by firmware currently on the chip
getips ... Get a list with IPs of esp82xxs connected to your network
usbburn .. Burn via PRE-RELEASE USB loader (will probably change)
usbweb ... Burn webpage by PRE-RELEASE USB loader (will probably change)

More commands: all, clean, purge
endef

define inside_docker
# Cross-compile toolchain in a docker image
 ifeq ($(strip $(DOCKER)), yes)
  INCL += $(DOCKER_PREFIX)/esp82xx/include $(DOCKER_PREFIX)
    $(eval SRCS:=$(addprefix $(DOCKER_PREFIX), $(SRCS)))
    $(eval FW_FILE1:=$(addprefix $(DOCKER_PREFIX), $(FW_FILE1)))
    $(eval FW_FILE2:=$(addprefix $(DOCKER_PREFIX), $(FW_FILE2)))
    $(eval TARGET:=$(addprefix $(DOCKER_PREFIX), $(TARGET)))
    $(eval CC:=$(DOCKCROSS) $(CC))
    $(eval ESP_ROOT:=$(DOCKER_SDK_DEFAULT))
    $(eval ESPTOOL_PY:=$(DOCKCROSS) $(ESPTOOL_PY))
  else
  DOCKCROSS=
  DOCKER_PREFIX=
  endif
endef

define outside_docker
# Make sure the actual burning of the chip is done with the system-wide esptool.py
# since it's the only one that has working (privileged) /dev/*USB access.
  ifeq ($(strip $(DOCKER)), yes)
    $(warning Warning: Docker cannot flash via in-docker esptool.py (yet) due to USB issues, see: http://bit.ly/2b9qFY2)
    $(eval ESPTOOL_PY:=$(shell which esptool.py))
    $(eval FW_FILE1:= image.elf-0x00000.bin)
    $(eval FW_FILE2:= image.elf-0x40000.bin)
  endif
endef

.PHONY : all clean cleanall netburn burnweb burn $(BIN_TARGET) netweb getips help
uniq = $(if $1,$(firstword $1) $(call uniq,$(filter-out $(firstword $1),$1)))

LIBS = main lwip ssl upgrade net80211 wpa phy lwip pp crypto
INCL = $(SDK)/include esp82xx/include .

FW_FILE1 = image.elf-0x00000.bin
FW_FILE2 = image.elf-0x40000.bin
TARGET = image.elf

SRCS =  esp82xx/fwsrc/uart.c \
  esp82xx/fwsrc/esp82xxutil.c \
  esp82xx/fwsrc/flash_rewriter.c \
  esp82xx/fwsrc/http.c \
  esp82xx/fwsrc/commonservices.c \
  esp82xx/fwsrc/http_custom.c \
  esp82xx/fwsrc/mdns.c \
  esp82xx/fwsrc/mfs.c \
  user/custom_commands.c \
  user/user_main.c

CFLAGS = -mlongcalls -Os $(addprefix -I,$(INCL) $(call uniq, $(patsubst %/,%,$(dir $(SRCS))))) $(OPTS) -DVERSSTR='$(VERSSTR)'

LDFLAGS_CORE = -Wl,--relax -Wl,--gc-sections -nostdlib -L$(XTLIB) \
  -L$(XTGCCLIB) $(addprefix $(SDK)/lib/lib,$(addsuffix .a,$(LIBS))) \
  $(XTGCCLIB) -T $(SDK)/ld/eagle.app.v6.ld
# -flto -Wl,--relax -Wl,--gc-sections

LINKFLAGS = $(LDFLAGS_CORE) -B$(XTLIB)

BIN_TARGET = $(PROJECT_NAME)-$(VERSION)-binaries.zip

ifneq (,$(findstring -DDEBUG,$(OPTS)))
  $(warning Debug is enabled!)
  FLASH_WRITE_FLAGS += --verify
endif

##########################################################################RULES

help :
	$(info $(value USAGE))
	@true

all : $(FW_FILE1) $(FW_FILE2)

$(FW_FILE1) $(FW_FILE2) : $(TARGET)
	$(ESPTOOL_PY) elf2image $(TARGET)

$(TARGET) : $(SRCS) Makefile
	$(eval $(call inside_docker))
	$(CC) $(CFLAGS) $(SRCS) -flto $(LINKFLAGS) -o $(TARGET)

debug : $(TARGET)
	nm -S -n $(TARGET) > image.map
	$(PREFIX)objdump -S $(TARGET) > image.lst
	$(PREFIX)size -A $(TARGET) | grep -v debug



ifeq ($(CHIP), 8285)
burn : $(FW_FILE1) $(FW_FILE2)  
	$(eval $(call outside_docker))
	($(ESPTOOL_PY) $(FWBURNFLAGS) --port $(PORT) write_flash $(FLASH_WRITE_FLAGS) 0x00000 $(FW_FILE1) 0x40000 $(FW_FILE2))||(true)
else ifeq ($(CHIP), 8266)
burn : $(FW_FILE1) $(FW_FILE2)
	$(eval $(call outside_docker))
	($(ESPTOOL_PY) $(FWBURNFLAGS) --port $(PORT) write_flash $(FLASH_WRITE_FLAGS) 0x00000 $(FW_FILE1) 0x40000 $(FW_FILE2))||(true)
else
	$(error Error: Unknown chip '$(CHIP)')
endif

burnweb :
	$(eval $(call outside_docker))
	@cd web && $(MAKE) $(MFLAGS) $(MAKEOVERRIDES) clean page.mpfs #Always rebuild page.mpfs
	($(ESPTOOL_PY) $(FWBURNFLAGS) --port $(PORT) write_flash $(PAGE_OFFSET) web/page.mpfs)||(true)

#If you have space, MFS should live at 0x100000. It can also live at
#0x10000. But, then it is limited to 180kB. You might need to do this if
# you have a 512kB, or 1M ESP variant.

netburn : $(FW_FILE1) $(FW_FILE2)
	$(eval $(call outside_docker))
	@cd web && $(MAKE) $(MFLAGS) $(MAKEOVERRIDES) execute_reflash
	web/execute_reflash $(IP) $(FW_FILE1) $(FW_FILE2)

netweb :
	@cd web && $(MAKE) $(MFLAGS) $(MAKEOVERRIDES) push


usbburn : $(FW_FILE1) $(FW_FILE2)
	web/execute_reflash USB $(FW_FILE1) $(FW_FILE2)

usbweb : $(FW_FILE1) $(FW_FILE2)
	@cd web && $(MAKE) $(MFLAGS) $(MAKEOVERRIDES) usbpush

$(BIN_TARGET): $(FW_FILE1) $(FW_FILE2)
	@cd web \
	 && $(MAKE) $(MFLAGS) $(MAKEOVERRIDES) page.mpfs \
	 && $(MAKE) $(MFLAGS) $(MAKEOVERRIDES) execute_reflash \
	 && $(MAKE) $(MFLAGS) $(MAKEOVERRIDES) pushtodev \
	 && cd ..
	zip $@ $(FW_FILE1) $(FW_FILE2) web/execute_reflash web/mfsmaker web/pushtodev web/page.mpfs

getips:
	$(info Detecting possible IPs for ESP82XX modules...)
	$(info Needs 'nmap' and takes some time especially if none are connected)
	sudo nmap -sP 192.168.0.0/24 | grep -iP "espressif|esp" -B2 | grep -oP "(\d{1,3}\.){3,3}\d\d{1,3}"

clean :
	$(RM) $(patsubst %.S,%.o,$(patsubst %.c,%.o,$(SRCS))) $(TARGET) image.map image.lst $(CLEAN_EXTRA)

purge : clean
	@cd web && $(MAKE) $(MFLAGS) $(MAKEOVERRIDES) clean
	$(RM) $(FW_FILE1) $(FW_FILE2) $(BIN_TARGET)

bump_submodule :
	cd esp82xx; git pull origin master; cd ..

